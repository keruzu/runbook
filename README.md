
# Runbooks
A runbook is a description of a service from the SRE perspective (ie from *inside* the sausage factory).

We are concerned about what the service is, how to know when the service is dead and how to keep the service running.

A runbook should be able to answer "What's that???" questions and also "How do I do X?" questions.

I generally try to start my solution architecture by filling out a runbook, so then I can capture all of the questions
(and later answers!) that I have from the various stakeholders. Once I have enough information to roughly understand
how people and other systems will use the system, then the completed runbook becomes my final project artifact.

## Architecture
This section covers the "What's that???" questions.

### About the Diagrams
I prefer the [C4 Model](https://c4model.com/) for diagrams.

According to the model, there are four levels of detail:

* **System Context**: All stakeholders should be able to read and understand this section. No product names, just areas of responsibility.
* **Container**: Nope, not that kind of container -- just a group of things. At this level we see applications and data stores.
* **Components**: A breakdown of each of the above containers into the nitty gritty of IaC-level configuration.
* **Code**: These diagrams should be automatically generated by your IDE or other tools.

The big idea is that we go from a very high-level view all the way down to where the unit-tests live.

We will show the users the System Context diagram in their landing page. The rest of the diagrams are for our internal use.

### Service Requirements Definition
This is where we capture the information that's usually lost to history: functional and non-functional requirements.

#### Functional Requirements
In bullet points, this should be statements that all start with "Our user should be able to ..."

In another bullet point list, we should list out the things are specifically **NOT** going to be done.

#### Non-Functional Requirements
In bullet points, list out information that will form the basis of any SLAs or SLOs.

In another bullet point list, we should list out the things are specifically **NOT** going to be targets.

#### Service Level Agreement (SLA)
If we are responsible to an outside party, we need to document what we've agreed to do.
If there are different agreements to different parties, each should be identified here.

#### Service Level Objective (SLO)
These are our internal targets for the service, and should include availability targets as well as performance targets.

### Using the Service
This is the advertising to our user community about what the service is and why they would want to use it.
We should also be able to use the contents of this page for any presentations about our service to any interested party.

Our big picture information (literally the System Context diagram), and try to
let people know what they can expect, and also (just as importantly) what **NOT** to expect.

Should include a Responsible / Accountable / Consulted / Involved (RACI) matrix to help people understand what's expected of them.

Link to our service's catalog of use cases or modules, if this exists. 

Also need to include information about how to contact the team (eg tickets, email, instant messenger) and escalation points.

Note that any emails provided should always be to a mailing list. Individual email accounts are subject to change as people take on new
responsibilities, go on holidays, etc etc.

### Service Maps
On this page I start with the System Container diagram(s) (ie the second-highest-zoom-level of my maps).
This map will show the containers, which will zoom into the lower level components.

Any research or background material that went into the planning will be linked for historical perspective.

### Component Map: Item 1
For each component, a separate page that headlines the Component diagram.

Here are the types of information displayed on the top-level page:

* Source code repositories
* Related AWS accounts, GCP projects or Azure subscriptions
* Related objects (eg S3 buckets, Kubernetes clusters)
* IAM roles used
* Deployment information such as Jenkins configuration required (eg stages, secrets)
* Secret stores and keys used to 

Specific feature support is broken out under further pages. Examples of underlying pages:

* Schema descriptions for your data store
* Input validation controls (eg JSON schema, Python `pydantic`)
* Feature deep dives

Your wki should include tags, so these tags should match procedures for automatic linking.


## Catalogs
If there are modules of functionality (eg plugins, Terraform modules) or use cases, here's where we'll put in support materials.

## Schedules
### Automated
Need to record information about:

* scheduling information (eg every Thursday at 1am)
* where the automation is scheduled (eg `cron`, AWS Eventbridge, Apache Airflow) and links to the scheduler
* what the job does
* link to troubleshooting procedure

### Manual
Example activities:

* Daily health checks: in theory, this isn't necessary because everything is automated. In practice...
* Audits: some organizations require yearly reviews with security team for compliance reasons
* Secret refreshes: do we need to update SSL certificates or rotate credentials to an outside service?

## Procedures
Each one of these documents should be titled as if it starts with "How do I do ..."

If you are here, you know what's going on and are specifically looking to solve a particular issue.
The goal here is to provide "Just In Time" knowledge for busy people. Provide step-by-step instructions and copy-n-paste-friendly snippets.
If required, supporting information about how to choose various options and how it affects the operations of the system.

### End-User Procedures
Each document here should have a format similar to the following:

* Task description and desired outcomes
* Pre-requisites: eg permissions, other objects created
* Task procedure
* Example

Assume that the user doesn't really know about the service, but has the Internet so that they can figure out other pieces.

In addition, information about:

* Naming schemes: eg "all security groups end with -sg"
* Data types and units: Do I really have to put in the number of milliseconds (ie strictly an integer), or can I put in `1hr`?
* Other tips: For example, "Use -1 here to indicate no limits on transaction volume"

### Admin Procedures
Here we are address day-to-day operations support.

For example:

* Daily health checks
* Deploying changes to the service
* New admin onboarding
* Security refresh procedures
* Opening tickets with a vendor
* Escalating tickets with a vendor
* Escalating issues internally


### Troubleshooting Procedures
If you're here, it's probably 3am and it's a crisis for someone.

There should be a troubleshooting flowchart, and each underly page should should support that flowchart.

Every page should include

* steps to determine if this component is working or not
* error output of anything found previously. This is important because we'll be searching for this if it happens again.

Of course, this document can also serve as the basis for any business continuity planning.

## Known Issues
There are some things in our control, and some things outside of our control.

And there can also be a delay between when an issue is detected and when it is resolved.
We record each issue on a separate page and indicate it's status.

For example:

* Issue symptoms: "What the user sees" or other information to indicate that there's an issue
* Impact: how the issue affects the service eg loss of data, wrong spelling, delay
* Impact severity: high, medium, low type severity 
* Remediation, workaround or resolution: describe with enough detail that someone else can do it
* Status: Is this being worked on? Is this still active? Will this ever be addressed?

## Roadmap
This set of pages contains any upcoming features or fixes.

Once a fix is complete, update the Architecture section to ensure that it matches the deployment.

### Change History
Depending on the environment, you may or may not have to provide external information about changes.

This can also be useful to match deployment times to issues for troubleshooting.

Ideally, you should be able to use a tool that can link specific pull requests to your service's KPIs and show
causal links to issues.


## Post Mortems
This section describes your bumps in the night and near misses.
I've included a variation of the [Google SRE post-mortem document](https://sre.google/sre-book/example-postmortem/) that might fit your purposes.

We should have enough information to help determine **process** issues. The problem isn't the person,
it's the process. No names should be used, only roles.


